/**
 * uploadPhoto.js
 * Robust image upload helper for nodejs-insta-private-api.
 *
 * Usage:
 *   const uploadPhoto = require('./uploadPhoto');
 *   const uploadId = await uploadPhoto(session, photoBuffer, { mimeType: 'image/jpeg' });
 *
 * Notes:
 * - Expects a valid `session` object from nodejs-insta-private-api with `request.send`.
 * - Handles JPEG/PNG; converts common metadata to Instagram-friendly headers.
 * - Returns a string upload_id to be used in the subsequent direct send call.
 */

const { v4: uuidv4 } = require('uuid');

/**
 * Validate buffer and mime type
 */
function validateImageInput(photoBuffer, mimeType) {
  if (!photoBuffer || !Buffer.isBuffer(photoBuffer) || photoBuffer.length === 0) {
    throw new Error('uploadPhoto: photoBuffer must be a non-empty Buffer.');
  }
  const allowed = ['image/jpeg', 'image/jpg', 'image/png'];
  if (!allowed.includes(mimeType)) {
    throw new Error(`uploadPhoto: mimeType must be one of ${allowed.join(', ')}.`);
  }
}

/**
 * Build Instagram rupload params for photo
 */
function buildRuploadParams(uploadId, mimeType) {
  // Instagram expects media_type=1 for photo.
  // image_compression string must be JSON but sent as string.
  const isJpeg = mimeType === 'image/jpeg' || mimeType === 'image/jpg';
  const compression = isJpeg
    ? '{"lib_name":"moz","lib_version":"3.1.m","quality":"80"}'
    : '{"lib_name":"png","lib_version":"1.0","quality":"100"}';

  return {
    upload_id: uploadId,
    media_type: 1,
    image_compression: compression,
    // Optional hints commonly used by IG web clients
    xsharing_user_ids: JSON.stringify([]),
    // mark this upload as photo (not reels/clips)
    is_clips_media: false,
  };
}

/**
 * Upload a photo to Instagram's rupload endpoint.
 * Returns upload_id string on success.
 *
 * @param {object} session - An authenticated session with request.send({ url, method, headers, body })
 * @param {Buffer} photoBuffer - Image buffer (JPEG or PNG)
 * @param {object} [options]
 * @param {string} [options.mimeType='image/jpeg'] - 'image/jpeg' | 'image/png'
 * @param {string} [options.fileName] - Optional file name; autogenerated if not provided
 * @param {number} [options.quality] - 50..100 (only applies to JPEG header hint)
 * @param {AbortSignal} [options.signal] - Optional AbortSignal to cancel
 * @returns {Promise<string>} upload_id
 */
async function uploadPhoto(session, photoBuffer, options = {}) {
  const {
    mimeType = 'image/jpeg',
    fileName,
    quality,
    signal,
  } = options;

  validateImageInput(photoBuffer, mimeType);

  // Generate uploadId and object name used in rupload path
  const uploadId = Date.now().toString();
  const objectName = fileName
    ? sanitizeFileName(fileName, mimeType)
    : `${uuidv4()}.${mimeType === 'image/png' ? 'png' : 'jpg'}`;

  // Build rupload params
  const ruploadParams = buildRuploadParams(uploadId, mimeType);
  if (quality && Number.isFinite(quality)) {
    const q = Math.max(50, Math.min(100, Math.round(quality)));
    // override compression string for JPEG quality if provided
    if (mimeType === 'image/jpeg' || mimeType === 'image/jpg') {
      ruploadParams.image_compression = `{"lib_name":"moz","lib_version":"3.1.m","quality":"${q}"}`;
    }
  }

  // Headers expected by Instagram rupload (matching upload.repository.js format)
  const headers = {
    'X-FB-Photo-Waterfall-ID': uuidv4(),
    'X-Entity-Type': 'image/jpeg',
    'Offset': '0',
    'X-Instagram-Rupload-Params': JSON.stringify(ruploadParams),
    'X-Entity-Name': objectName,
    'X-Entity-Length': String(photoBuffer.length),
    'Content-Type': 'application/octet-stream',
    'Content-Length': String(photoBuffer.length),
    'Accept-Encoding': 'gzip',
  };

  const url = `/rupload_igphoto/${objectName}`;

  // Send the upload request
  try {
    const response = await session.request.send({
      url,
      method: 'POST',
      headers,
      data: photoBuffer,
      signal,
    });

    // Basic success validation (IG often returns JSON with upload_id or ok status)
    if (!response) {
      throw new Error('uploadPhoto: Empty response from Instagram rupload endpoint.');
    }

    // If response contains upload_id, prefer it; otherwise use our generated one
    const serverUploadId =
      (typeof response === 'object' && response.upload_id) ||
      (response?.body && parseUploadIdFromBody(response.body));

    return serverUploadId || uploadId;
  } catch (err) {
    const message = normalizeError(err);
    throw new Error(`uploadPhoto: Upload failed â€” ${message}`);
  }
}

/**
 * Ensure file name extension matches mime type; strip invalid chars.
 */
function sanitizeFileName(name, mimeType) {
  const safe = String(name).replace(/[^a-zA-Z0-9._-]/g, '_');
  const ext = safe.split('.').pop()?.toLowerCase();
  const desiredExt = mimeType === 'image/png' ? 'png' : 'jpg';
  if (ext !== desiredExt) {
    // replace or append correct extension
    const base = safe.replace(/\.[^.]+$/, '');
    return `${base}.${desiredExt}`;
  }
  return safe;
}

/**
 * Attempt to parse upload_id from response body if present.
 */
function parseUploadIdFromBody(body) {
  try {
    const text = Buffer.isBuffer(body) ? body.toString('utf8') : String(body || '');
    const json = JSON.parse(text);
    if (json && typeof json.upload_id === 'string') return json.upload_id;
    return null;
  } catch {
    return null;
  }
}

/**
 * Normalize common error shapes to readable text.
 */
function normalizeError(err) {
  if (!err) return 'Unknown error';
  if (typeof err === 'string') return err;
  if (err.message) return err.message;
  try {
    return JSON.stringify(err);
  } catch {
    return 'Unserializable error';
  }
}

module.exports = uploadPhoto;
